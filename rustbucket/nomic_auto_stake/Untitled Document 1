225477298
340617489
836981826
894422797
2929442403
4973911573
5578335057
6193465165
8303210335
10910019611
11670387591
14291698097
14748465926
15534487716
15595691544
16579172438
17642426919
17721362734
18472208397
21568596122
23023900563
23303761187
26444400062
26850389394
26906712906
29465046233
30570885989
30615517047
35404970137
37430802159

use std::process::{Command, exit};
use std::str;
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use chrono::{Local, DateTime, Utc, Duration as ChronoDuration, Timelike};
use colored::*;
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, Write};
use std::path::Path;




999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
999999999999999
use std::process::{Command, exit};
use std::str;
use std::thread;
use std::time::Duration;
use chrono::Local;
use colored::*;
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, Write};
use std::path::Path;

//const DIFFS_FILE: &str = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/voting_power_diffs.txt"; // File to store highest spreads
fn main() {
    let num_comparisons = 31; 
    let mut current_value = 0.000000;
    let mut previous_value = 0.000000;
    let mut amntgained = 0.0;
    let triggertime = 1;
    let threshold = 19.48;
    let _bal_output = Command::new("nomic")
     .arg("balance")
     .output()
     .expect("Failed to execute command");

    loop {
        let current_time = Local::now();
        let formatted_time = current_time.format("%I:%M:%S %p   %a-%b-%Y").to_string();

        let output = Command::new("nomic")
            .arg("delegations")
            .output()
            .expect("Failed to execute command");

        let output_str = str::from_utf8(&output.stdout).expect("Failed to convert to string");

        let liquid_str = match output_str.lines().find(|line| line.contains("liquid=")) {
            Some(liquid_str) => liquid_str,
            None => {
                println!("No liquid amount found. Rerunning the script...");
                Command::new("cargo")
                    .arg("run")
                    .spawn()
                    .expect("Failed to rerun the script");
                exit(0);
            }
        };

        let liquid_amount_str = liquid_str
            .splitn(2, "liquid=")
            .nth(1)
            .unwrap()
            .split_whitespace()
            .next()
            .unwrap()
            .replace(",", "");

        let claimable_amount: f64 = liquid_amount_str.parse().expect("Failed to parse liquid amount");

        let formatted_claimable = claimable_amount / 1_000_000.0;
        current_value = formatted_claimable;
        amntgained = current_value - previous_value;

        if formatted_claimable > threshold {
            let _ = Command::new("nomic")
                .arg("claim")
                .status()
                .expect("Failed to execute claim command");
            prepare_compound();
        } else if previous_value != 0.00000 && formatted_claimable < threshold {
            println!(
                "{}", format! ("{}   Claimable: {:.6}   Gained: {:.6}",
                formatted_time,
                formatted_claimable,
                amntgained).bright_yellow().on_black()
            );
            let _time_to_claim = calc_tt_claim(formatted_claimable, threshold, amntgained, triggertime);
            println!("{}",format! ("Time to claim {}",_time_to_claim).bright_yellow().on_black());
       	    calculate_voting_power_spreads(num_comparisons); 
            println!("{}", "--------------------------------------------------------------------------------------".bright_black().on_black());
        }          
       previous_value = current_value;    
       thread::sleep(Duration::from_secs(triggertime));
  
    }
}


fn prepare_compound(){
        ////////NOM BALANCE///////////////////////////////
        // Step 1: Execute the `nomic balance` command
        let _bal_output = Command::new("nomic")
            .arg("balance")
            .output()
            .expect("Failed to execute command");

        // Step 2: Convert output to string and parse the liquid amount
        let _bal_output_str = str::from_utf8(&_bal_output.stdout).expect("Failed to convert to string");
        // println!("Output from `nomic delegations`: {}", output_str);  // Debugging output

        // Find the line containing "NOM"
        let nom_str = _bal_output_str
            .lines()
            .find(|line| line.contains("NOM"))
            .expect("No liquid amount found");

        // Extract the number directly after "NOM"
        let nom_bal_str = nom_str
            .splitn(2, "NOM")  // Split into two parts at "liquid="
            .next()                // Get the second part (everything after "liquid=")
            .unwrap()
            .trim()
            .split_whitespace()    // Split by whitespace to isolate the number
            .last()                // Get the first segment, which should be the number
            .unwrap()
            .replace(",", "");     // Remove commas if the number has thousand separators

        // println!("Nomic balance: {}", nom_bal_str);  // Debugging output
         let nom_bal_amount: f64 = nom_bal_str
            .parse()
            .expect("Failed to parse balance amount");
	let delegate_amount = nom_bal_amount - 100_000.0;
	thread::sleep(Duration::from_secs(2));
    	let _ = Command::new("nomic")
        .arg("delegate")
        .arg("nomic1tvgzmmgy9lj3jvtqk2pagg0ng5rk8ajt5nc86u")
        .arg(&delegate_amount.to_string())
        .status()
        .expect("Failed to execute command");
        
        let formatted_delegated: f64 = delegate_amount / 1_000_000.0;
        println!("You have claimed and staked {}", formatted_delegated.to_string().bright_green());
       // println! ("--------------------------------------------------------------------------------------");

}
 fn calc_tt_claim(claimable_amount: f64, threshold: f64, amntgained: f64, triggertime: u64) -> String {
    if amntgained <= 0.0 {
        return "indefinite".to_string();
    }

    let amount_needed = threshold - claimable_amount;
    let intervals_needed = (amount_needed / amntgained).ceil() as u64;
    let total_seconds = intervals_needed * triggertime;

    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;
    let seconds = total_seconds % 60;

    format!("{:02} hours {:02} minutes {:02} seconds", hours, minutes, seconds)
}     



fn  calculate_voting_power_spreads(num_comparisons: usize) {
    let target_address = "nomic1tvgzmmgy9lj3jvtqk2pagg0ng5rk8ajt5nc86u";
    let file_path = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/voting_power_diffs.txt"; // File to save smallest spreads

    // Load smallest spreads from the file
    let mut smallest_spreads = vec![f64::INFINITY; num_comparisons];
    if Path::new(file_path).exists() {
        let file = File::open(file_path).expect("Unable to open file");
        let reader = io::BufReader::new(file);
        for (i, line) in reader.lines().enumerate() {
            if i < num_comparisons {
                if let Ok(value) = line {
                    if let Ok(spread) = value.trim().parse::<f64>() {
                        smallest_spreads[i] = spread;
                    }
                }
            }
        }
    }

    // Run the nomic validators command
    let output = Command::new("nomic")
        .arg("validators")
        .output()
        .expect("Failed to execute command");

    let output_str = str::from_utf8(&output.stdout).expect("Failed to convert to string");

    // Find the target address, voting power, and moniker
    let lines = output_str.lines().collect::<Vec<_>>();
    let mut target_voting_power: Option<f64> = None;
    let mut voting_powers: Vec<f64> = Vec::new();
    let mut monikers: Vec<String> = Vec::new();

    // Look for the target address, its voting power, and moniker
    let mut target_index: Option<usize> = None;
    for (i, line) in lines.iter().enumerate() {
        if line.contains(target_address) {
            target_index = Some(i);
            if let Some(vp_line) = lines.get(i + 1) {
                if let Some(vp_str) = vp_line.split("VOTING POWER: ").nth(1) {
                    target_voting_power = Some(vp_str.trim().replace(",", "").parse::<f64>().expect("Failed to parse target voting power"));
                }
            }

            if let Some(moniker_line) = lines.get(i + 2) {
                let moniker = moniker_line.replace("MONIKER: ", "");
                monikers.push(moniker.trim().to_string());
            }

            break;
        }
    }

    // If the target address is found, look back for previous addresses, voting powers, and monikers
    if let Some(index) = target_index {
        let mut look_back_count = 0;
        let mut i = index as isize - 1;

        while look_back_count < num_comparisons && i >= 0 {
            let line = lines[i as usize];
            if line.contains("nomic1") {
                if let Some(vp_line) = lines.get(i as usize + 1) {
                    if let Some(vp_str) = vp_line.split("VOTING POWER: ").nth(1) {
                        let voting_power = vp_str.trim().replace(",", "").parse::<f64>().expect("Failed to parse voting power");
                        voting_powers.push(voting_power);
                    }
                }

                if let Some(moniker_line) = lines.get(i as usize + 2) {
                    let moniker = moniker_line.replace("MONIKER: ", "");
                    monikers.push(moniker.trim().to_string());
                }

                look_back_count += 1;
            }
            i -= 1;
        }
    }

    // If we have the target voting power and enough previous voting powers, calculate the spreads
    if let Some(vp1) = target_voting_power {
        let vp1 = vp1;

        let voting_powers = voting_powers.into_iter().take(num_comparisons).collect::<Vec<_>>();
        let monikers = monikers.into_iter().take(num_comparisons).collect::<Vec<_>>();

        let vp_spreads = voting_powers.iter().map(|&vp| (vp - vp1).abs()).collect::<Vec<_>>();


println!("      |   Current  | |    Best    |   Change  |   Moniker   ");
for (i, spread) in vp_spreads.iter().enumerate() {
    if let Some(moniker) = monikers.get(i + 1) {
        // Format spread for comparison by dividing by 1_000_000.0
        let formatted_spread = spread / 1_000_000.0;
        
        // Format smallest_spreads for comparison by dividing by 1_000_000.0
        let formatted_best = smallest_spreads[i] / 1_000_000.0;
        
        // Calculate the spread between current and best
        let spread_change = (formatted_spread - formatted_best).abs();
        
        if formatted_spread < formatted_best {
            smallest_spreads[i] = *spread; // Update smallest spread with original value
        }
        
        let spread_color = if formatted_spread > formatted_best { "red" } else { "green" };
        let spread_color = if spread_change > 0.0 { "yellow" } else { "green" };
        
        println!(
            "{:>5} | {:>10} | | {:>10} | {:>10} | {}",
            format!("({}) ", i + 1),
            format!("{:.2} ", formatted_spread).bright_yellow(),
            format!("{:.2} ", formatted_best).color(spread_color),
            format!("{:.2} ", spread_change).color(spread_color),
            moniker
        );
    }
}
        // Save the smallest spreads back to the file
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(file_path)
            .expect("Unable to open file for writing");
        for spread in smallest_spreads.iter() {
            writeln!(file, "{}", spread).expect("Unable to write to file");
        }
    } else {
        println!("Could not find the target voting power.");
    }
}
====================================================================================================================
use std::process::{Command, exit};
use std::str;
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use chrono::Local;
use colored::*;
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, Write};
use std::path::Path;

//const DIFFS_FILE: &str = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/voting_power_diffs.txt"; // File to store highest spreads
fn main() {
    let compare_qnty = 31; 
    let mut current_value = 0.000000;
    let mut previous_value = 0.000000;
    let mut amntgained = 0.0;
    let triggertime = 1;
    let threshold = 19.48;
    let _bal_output = Command::new("nomic")
     .arg("balance")
     .output()
     .expect("Failed to execute command");

    loop {
        let current_time = Local::now();
        let formatted_time = current_time.format("%I:%M:%S %p   %a-%b-%Y").to_string();

        let output = Command::new("nomic")
            .arg("delegations")
            .output()
            .expect("Failed to execute command");

        let output_str = str::from_utf8(&output.stdout).expect("Failed to convert to string");

        let liquid_str = match output_str.lines().find(|line| line.contains("liquid=")) {
            Some(liquid_str) => liquid_str,
            None => {
                println!("No liquid amount found. Rerunning the script...");
                Command::new("cargo")
                    .arg("run")
                    .spawn()
                    .expect("Failed to rerun the script");
                exit(0);
            }
        };

        let liquid_amount_str = liquid_str
            .splitn(2, "liquid=")
            .nth(1)
            .unwrap()
            .split_whitespace()
            .next()
            .unwrap()
            .replace(",", "");

        let claimable_amount: f64 = liquid_amount_str.parse().expect("Failed to parse liquid amount");

        let formatted_claimable = claimable_amount / 1_000_000.0;
        current_value = formatted_claimable;
        amntgained = current_value - previous_value;

        if formatted_claimable > threshold {
            let _ = Command::new("nomic")
                .arg("claim")
                .status()
                .expect("Failed to execute claim command");
            prepare_compound(compare_qnty);
        } else if previous_value != 0.00000 && formatted_claimable < threshold {
            println!(
                "{}", format! ("{}   Claimable: {:.6}   Gained: {:.6}",
                formatted_time,
                formatted_claimable,
                amntgained).bright_yellow().on_black()
            );
            let _time_to_claim = calc_tt_claim(formatted_claimable, threshold, amntgained, triggertime);
            println!("{}",format! ("Time to claim {}",_time_to_claim).bright_yellow().on_black());
       	    calculate_voting_power_spreads(compare_qnty);
            println!("{}", "--------------------------------------------------------------------------------------".bright_black().on_black());
        }          
       previous_value = current_value;    
       thread::sleep(Duration::from_secs(triggertime));
    }
     
}


fn prepare_compound(compare_qnty: usize){
        ////////NOM BALANCE///////////////////////////////
        // Step 1: Execute the `nomic balance` command
        let _bal_output = Command::new("nomic")
            .arg("balance")
            .output()
            .expect("Failed to execute command");

        // Step 2: Convert output to string and parse the liquid amount
        let _bal_output_str = str::from_utf8(&_bal_output.stdout).expect("Failed to convert to string");
        // println!("Output from `nomic delegations`: {}", output_str);  // Debugging output

        // Find the line containing "NOM"
        let nom_str = _bal_output_str
            .lines()
            .find(|line| line.contains("NOM"))
            .expect("No liquid amount found");

        // Extract the number directly after "NOM"
        let nom_bal_str = nom_str
            .splitn(2, "NOM")  // Split into two parts at "liquid="
            .next()                // Get the second part (everything after "liquid=")
            .unwrap()
            .trim()
            .split_whitespace()    // Split by whitespace to isolate the number
            .last()                // Get the first segment, which should be the number
            .unwrap()
            .replace(",", "");     // Remove commas if the number has thousand separators

        // println!("Nomic balance: {}", nom_bal_str);  // Debugging output
         let nom_bal_amount: f64 = nom_bal_str
            .parse()
            .expect("Failed to parse balance amount");
	let delegate_amount = nom_bal_amount - 100_000.0;
	thread::sleep(Duration::from_secs(2));
    	let _ = Command::new("nomic")
        .arg("delegate")
        .arg("nomic1tvgzmmgy9lj3jvtqk2pagg0ng5rk8ajt5nc86u")
        .arg(&delegate_amount.to_string())
        .status()
        .expect("Failed to execute command");
        
        let formatted_delegated: f64 = delegate_amount / 1_000_000.0;
        println!("You have claimed and staked {}", formatted_delegated.to_string().bright_green());
       // println! ("--------------------------------------------------------------------------------------");


}
 fn calc_tt_claim(claimable_amount: f64, threshold: f64, amntgained: f64, triggertime: u64) -> String {
    if amntgained <= 0.0 {
        return "indefinite".to_string();
    }

    let amount_needed = threshold - claimable_amount;
    let intervals_needed = (amount_needed / amntgained).ceil() as u64;
    let total_seconds = intervals_needed * triggertime;

    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;
    let seconds = total_seconds % 60;

    format!("{:02} hours {:02} minutes {:02} seconds", hours, minutes, seconds)
}     

fn calculate_voting_power_spreads(num_comparisons: usize) {
    let target_address = "nomic1tvgzmmgy9lj3jvtqk2pagg0ng5rk8ajt5nc86u";
    let file_path = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/voting_power_diffs.txt"; // File to save smallest spreads
    let current_spreads_path = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/current_voting_power_spreads.txt"; // File to save current spreads
    let last_save_time_path = "/home/vboxuser/_coding/rustbucket/nomic_auto_stake/src/last_save_time.txt"; // File to save the last save time

    // Load smallest spreads from the file
    let mut smallest_spreads = vec![f64::INFINITY; num_comparisons];
    let mut current_spreads = Vec::new();
    if Path::new(file_path).exists() {
        let file = File::open(file_path).expect("Unable to open file");
        let reader = io::BufReader::new(file);
        for (i, line) in reader.lines().enumerate() {
            if i < num_comparisons {
                if let Ok(value) = line {
                    if let Ok(spread) = value.trim().parse::<f64>() {
                        smallest_spreads[i] = spread;
                    }
                }
            }
        }
    }

    // Load current spreads if they exist
    if Path::new(current_spreads_path).exists() {
        let file = File::open(current_spreads_path).expect("Unable to open file");
        let reader = io::BufReader::new(file);
        for line in reader.lines() {
            if let Ok(value) = line {
                if let Ok(spread) = value.trim().parse::<f64>() {
                    current_spreads.push(spread);
                }
            }
        }
    }

    // Load the last save time
    let mut last_save_time = 0;
    if Path::new(last_save_time_path).exists() {
        let file = File::open(last_save_time_path).expect("Unable to open last save time file");
        let reader = io::BufReader::new(file);
        if let Some(Ok(line)) = reader.lines().next() {
            last_save_time = line.trim().parse::<u64>().expect("Failed to parse last save time");
        }
    }

    // Get the current system time in seconds
    let current_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();

    // Only proceed if at least 12 hours (43,200 seconds) have passed since the last save
    if current_time - last_save_time < 43_200 {
        println!("Less than 12 hours since the last save. Skipping this run.");
        return;
    }

    // Run the nomic validators command
    let output = Command::new("nomic")
        .arg("validators")
        .output()
        .expect("Failed to execute command");

    let output_str = std::str::from_utf8(&output.stdout).expect("Failed to convert to string");

    // Find the target address, voting power, and moniker
    let lines = output_str.lines().collect::<Vec<_>>();
    let mut target_voting_power: Option<f64> = None;
    let mut voting_powers: Vec<f64> = Vec::new();
    let mut monikers: Vec<String> = Vec::new();

    // Look for the target address, its voting power, and moniker
    let mut target_index: Option<usize> = None;
    for (i, line) in lines.iter().enumerate() {
        if line.contains(target_address) {
            target_index = Some(i);
            if let Some(vp_line) = lines.get(i + 1) {
                if let Some(vp_str) = vp_line.split("VOTING POWER: ").nth(1) {
                    target_voting_power = Some(vp_str.trim().replace(",", "").parse::<f64>().expect("Failed to parse target voting power"));
                }
            }

            if let Some(moniker_line) = lines.get(i + 2) {
                let moniker = moniker_line.replace("MONIKER: ", "");
                monikers.push(moniker.trim().to_string());
            }

            break;
        }
    }

    // If the target address is found, look back for previous addresses, voting powers, and monikers
    if let Some(index) = target_index {
        let mut look_back_count = 0;
        let mut i = index as isize - 1;

        while look_back_count < num_comparisons && i >= 0 {
            let line = lines[i as usize];
            if line.contains("nomic1") {
                if let Some(vp_line) = lines.get(i as usize + 1) {
                    if let Some(vp_str) = vp_line.split("VOTING POWER: ").nth(1) {
                        let voting_power = vp_str.trim().replace(",", "").parse::<f64>().expect("Failed to parse voting power");
                        voting_powers.push(voting_power);
                    }
                }

                if let Some(moniker_line) = lines.get(i as usize + 2) {
                    let moniker = moniker_line.replace("MONIKER: ", "");
                    monikers.push(moniker.trim().to_string());
                }

                look_back_count += 1;
            }
            i -= 1;
        }
    }

    // If we have the target voting power and enough previous voting powers, calculate the spreads
    if let Some(vp1) = target_voting_power {
        let vp1 = vp1;

        let voting_powers = voting_powers.into_iter().take(num_comparisons).collect::<Vec<_>>();
        let monikers = monikers.into_iter().take(num_comparisons).collect::<Vec<_>>();

        let vp_spreads = voting_powers.iter().map(|&vp| (vp - vp1).abs()).collect::<Vec<_>>();

        println!("      |   Current  | |    Best    |   Change  | Est. Time to Zero |  Moniker   |   ");
        for (i, spread) in vp_spreads.iter().enumerate() {
            if let Some(moniker) = monikers.get(i + 1) {
                let formatted_spread = spread / 1_000_000.0;
                let formatted_best = smallest_spreads[i] / 1_000_000.0;
                let spread_change = (formatted_spread - formatted_best).abs();

                if formatted_spread < formatted_best {
                    smallest_spreads[i] = *spread;
                }

                let spread_color = if formatted_spread > formatted_best { "red" } else { "green" };
                let change_color = if spread_change > 0.0 { "yellow" } else { "green" };

                // Estimate time to zero
                let est_time_to_zero = if current_spreads.len() >= 2 {
                    let rate = (current_spreads[current_spreads.len() - 1] - current_spreads[current_spreads.len() - 2]) / (current_spreads.len() as f64);
                    if rate != 0.0 {
                        format!("{:.2} days", formatted_spread / rate)
                    } else {
                        "N/A".to_string()
                    }
                } else {
                    "N/A".to_string()
                };

                println!(
                    "{:>5} | {:>10} | | {:>10} | {:>10} | {:>10} | {}",
                    format!("({}) ", i + 1),
                    format!("{:.2} ", formatted_spread).bright_yellow(),
                    format!("{:.2} ", formatted_best).color(spread_color),
                    format!("{:.2} ", spread_change).color(change_color),
                    est_time_to_zero,
                    moniker
                );
            }
        }

        // Save the smallest spreads back to the file
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(file_path)
            .expect("Unable to open file for writing");
        for spread in smallest_spreads.iter() {
            writeln!(file, "{}", spread).expect("Unable to write to file");
        }

        // Save current spreads if flag is true
        let mut current_file = OpenOptions::new()
            .write(true)
            .create(true)
            .append(true)
            .open(current_spreads_path)
            .expect("Unable to open file for writing");
        for spread in vp_spreads.iter() {
            writeln!(current_file, "{}", spread).expect("Unable to write to file");
        }

        // Save the current time as the last save time
        let mut last_save_file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(last_save_time_path)
            .expect("Unable to open file for writing");
        writeln!(last_save_file, "{}", current_time).expect("Unable to write last save time");
    } else {
        println!("Target address not found in the output.");
    }
}


